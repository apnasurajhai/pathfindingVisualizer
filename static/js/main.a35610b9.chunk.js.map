{"version":3,"sources":["Components/PathfindingVisualizer/Node.jsx","Components/PathfindingVisualizer/Sidebar.jsx","Components/PathfindingVisualizer/Footer.jsx","Components/Algorithms/dijkstras.js","Components/Algorithms/BidirectionSearch.js","Components/Algorithms/depthFirstSearch.js","Components/Algorithms/breadthFirstSearch.js","Components/Algorithms/Astar.js","Components/Algorithms/GreedyBFS.js","Components/MazesAndPatterns/RecursiveDivision.js","Components/MazesAndPatterns/RecursiveHorizontal.js","Components/MazesAndPatterns/RecursiveVertical.js","Components/PathfindingVisualizer/select_algorithm.mp4","Components/PathfindingVisualizer/select_mazes.mp4","Components/PathfindingVisualizer/select_speed.mp4","Components/PathfindingVisualizer/visualize.mp4","Components/PathfindingVisualizer/clearGrid.mp4","Components/PathfindingVisualizer/clearPath.mp4","Components/PathfindingVisualizer/drawMaze.mp4","Components/PathfindingVisualizer/createWalls.mp4","Components/PathfindingVisualizer/Tutorial.jsx","Components/PathfindingVisualizer/Visualizer.jsx","Components/MazesAndPatterns/RandomWalls.js","App.js","reportWebVitals.js","index.js"],"names":["Node","props","state","cellHeight","this","isStart","isFinish","isWall","row","col","isVisited","isShortest","onMouseEnter","onMouseDown","onMouseUp","width","height","numRows","numCols","classes","cellWidth","Math","floor","id","className","style","Component","Sidebar","showSidebar","setState","sidebar","myFunction1","document","getElementById","classList","toggle","myFunction2","myFunction3","selection","visualizing","algorithm","updateAlgorithmState","console","log","pathState","clearPath","mazeGeneration","mazeState","clearGridPartially","updateMazeValueState","generateRandomWalls","generateRecursiveDivision","generateRecursiveVertical","generateRecursiveHorizontal","sidebarSpeed","speedVal","updateSidebarSpeed","updateSpeed","window","onclick","event","target","matches","i","dropdowns","getElementsByClassName","length","openDropdown","contains","remove","Fragment","textDecoration","color","to","type","onClick","selectAlgorithm","generateMaze","changeSpeed","href","Footer","clearGrid","updatePathState","updateMazeState","visualizeDijkstra","visualizeAstar","visualizeGreedyBFS","visualizeBidirectionalBFSSearch","visualizeBFS","visualizeDFS","visualizeAlgorithm","dijkstras","grid","startNode","finishNode","distance","unvisitedNodes","nodes","node","push","getNodes","visitedNodesInOrder","sort","a","b","closestNode","shift","Infinity","updateUnvisitedNeighbours","unvisitedNeighbours","neighbours","filter","neighbour","getUnvisitedNeighbours","unvisitedNeighbour","previousNode","isValid","dfs","finishCol","depthFirstSearch","finishRow","dirx","diry","newRow","newCol","neighbourNotInUnvisitedNodes","manhattenDistance","abs","getNeighbours","euclideanDistance","x","y","sqrt","RecursiveDivision","walls","horizontal","scale","recursiveWalls","vertical","dir","num","getRandomIndex","addIntoWalls","slice","indexOf","removeRandomNode","tempWalls","temp","splice","len","random","randomNumbers","wall","ans","arr","RecursiveHorizontal","breakRow","RecursiveVertical","Tutorial","querySelectorAll","forEach","play","addEventListener","paused","pause","currentTime","src","video1","video2","video3","video4","video5","video6","video7","video8","initialNum","numColumns","getInitialNum","innerWidth","innerHeight","initialNumRows","initialNumCols","startAndfinish","randomNums","startNodeRow","startNodeCol","finishNodeRow","finishNodeCol","getRandomNums","getStartFinishNode","Visualizer","nodesInShortestPathOrder","currentNode","unshift","animateShortestPath","setTimeout","newGrid","updateNodesForRender","speed","animateAlgorithm","newNode","animateMaze","newGridWithMaze","mazeSpeed","updateDimensions","mouseIsPressed","maze","rows","cols","wallsToPutOnNodes","RandomWalls","pathSpeed","value","getNewGridWithWalls","getInitialGrid","getGridWithoutPath","visitedNodesOrder","q1","q2","table","tmp","j","row1","col1","row2","col2","newLvl","newRow1","newRow2","newCol1","newCol2","BidirectionSearch","BSNodesInShortestPathOrder","animateBidirectionalAlgorithm","animateShortestPathForBS","updateNodesForRenderBS","bfs","totalDistance","Astar","GreedyBFS","bind","exact","path","map","currRow","cell","currCell","handleMouseDown","handleMouseEnter","handleMouseUp","currentRow","createNode","randomNums1","randomNums2","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.a35610b9.chunk.js","sourcesContent":["import React, { Component } from \"react\";\r\nimport \"./Node.css\";\r\n\r\nclass Node extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {};\r\n  }\r\n\r\n  render() {\r\n    const {\r\n      isStart,\r\n      isFinish,\r\n      isWall,\r\n      row,\r\n      col,\r\n      isVisited,\r\n      isShortest,\r\n      onMouseEnter,\r\n      onMouseDown,\r\n      onMouseUp,\r\n      width,\r\n      height,\r\n      numRows,\r\n      numCols,\r\n    } = this.props;\r\n\r\n    const classes = isStart\r\n      ? \"node node-start\"\r\n      : isFinish\r\n      ? \"node node-finish\"\r\n      : isWall\r\n      ? \"node node-wall\"\r\n      : isShortest\r\n      ? \"node node-shortest-path\"\r\n      : isVisited\r\n      ? \"node node-visited\"\r\n      : \"node\";\r\n\r\n    // This below values are each individual nodes widht and height.\r\n    let cellWidth = Math.floor((width - 15) / numCols);\r\n    let cellHeight;\r\n    if (width > 1500) {\r\n      cellHeight = Math.floor((height - 70) / numRows);\r\n    } else if (width > 1000) {\r\n      cellHeight = Math.floor((height - 70) / numRows);\r\n    } else if (width > 500) {\r\n      cellHeight = Math.floor((height - 60) / numRows);\r\n    } else if (width > 0) {\r\n      cellHeight = Math.floor((height - 50) / numRows);\r\n    }\r\n\r\n    return (\r\n      <div\r\n        id={`node-${row}-${col}`}\r\n        className={`${classes}`}\r\n        style={{ \"--width\": `${cellWidth}px`, \"--height\": `${cellHeight}px` }}\r\n        onMouseDown={() => onMouseDown(row, col)}\r\n        onMouseUp={() => onMouseUp()}\r\n        onMouseEnter={() => onMouseEnter(row, col)}\r\n      ></div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Node;\r\n","import React, { Component, useState } from \"react\";\r\nimport \"./Sidebar.css\";\r\nimport { FaBars } from \"react-icons/fa\";\r\nimport { Link } from \"react-router-dom\";\r\n\r\nclass Sidebar extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      sidebar: false,\r\n    };\r\n  }\r\n  showSidebar = () => {\r\n    this.setState({ sidebar: !this.state.sidebar });\r\n  };\r\n  selectAlgorithm(selection) {\r\n    if (this.props.visualizing) {\r\n      return;\r\n    }\r\n\r\n    if (\r\n      this.props.algorithm === \"Visualize\" ||\r\n      this.props.algorithm === selection ||\r\n      this.props.algorithm === \"Select Algorithm!\"\r\n    ) {\r\n      this.props.updateAlgorithmState(selection);\r\n      console.log(this.props.algorithm);\r\n    } else if (this.props.pathState) {\r\n      this.props.clearPath();\r\n      this.props.updateAlgorithmState(selection);\r\n    } else {\r\n      console.log(\"y u clicking me again and again? please\");\r\n      this.props.updateAlgorithmState(selection);\r\n    }\r\n  }\r\n\r\n  // selectMaze(selection) {\r\n  //   if (this.props.visualizing || this.props.mazeGeneration) {\r\n  //     return;\r\n  //   }\r\n  //   if (selection === this.props.maze || this.props.maze === \"\") {\r\n  //     this.props.updateMazeState(selection);\r\n  //   } else if (this.props.mazeState) {\r\n  //     this.clearGrid();\r\n  //     this.props.updateMazeState(selection);\r\n  //   } else {\r\n  //     this.props.updateMazeState(selection);\r\n  //   }\r\n  // }\r\n\r\n  generateMaze(selection) {\r\n    if (this.props.visualizing || this.props.mazeGeneration) {\r\n      return;\r\n    }\r\n    if (this.props.mazeState || this.props.pathState) {\r\n      this.props.clearGridPartially();\r\n      console.log(\"are we ?\");\r\n    }\r\n    this.props.updateMazeValueState(true);\r\n    if (selection === \"Random Walls\") {\r\n      console.log(\"are we ?\");\r\n      this.props.generateRandomWalls();\r\n    } else if (selection === \"Recursive Division\")\r\n      this.props.generateRecursiveDivision();\r\n    else if (selection === \"Recursive Vertical\")\r\n      this.props.generateRecursiveVertical();\r\n    else if (selection === \"Recursive Horizontal\")\r\n      this.props.generateRecursiveHorizontal();\r\n  }\r\n\r\n  changeSpeed(sidebarSpeed) {\r\n    if (this.props.visualizing || this.props.mazeGeneration) {\r\n      return;\r\n    }\r\n    let speedVal = [];\r\n    if (sidebarSpeed === \"Slow\") speedVal = [60, 40];\r\n    else if (sidebarSpeed === \"Medium\") speedVal = [30, 25];\r\n    else if (sidebarSpeed === \"Fast\") speedVal = [5, 5];\r\n    this.props.updateSidebarSpeed(sidebarSpeed);\r\n    this.props.updateSpeed(speedVal[0], speedVal[1]);\r\n  }\r\n\r\n  myFunction1 = () => {\r\n    document.getElementById(\"myDropdown\").classList.toggle(\"show\");\r\n  };\r\n  myFunction2 = () => {\r\n    document.getElementById(\"myDropdown1\").classList.toggle(\"show1\");\r\n  };\r\n  myFunction3 = () => {\r\n    document.getElementById(\"myDropdown2\").classList.toggle(\"show2\");\r\n  };\r\n\r\n  // The below function is executed when you click on dropdown buttons, it will display dropdown content or will remove if you click it again.\r\n  componentDidMount() {\r\n    window.onclick = (event) => {\r\n      if (!event.target.matches(\".dropdown-button\")) {\r\n        var dropdowns = document.getElementsByClassName(\"dropdown-content\");\r\n        var i;\r\n        for (i = 0; i < dropdowns.length; i++) {\r\n          var openDropdown = dropdowns[i];\r\n          if (openDropdown.classList.contains(\"show\")) {\r\n            openDropdown.classList.remove(\"show\");\r\n          } else if (openDropdown.classList.contains(\"show1\")) {\r\n            openDropdown.classList.remove(\"show1\");\r\n          } else if (openDropdown.classList.contains(\"show2\")) {\r\n            openDropdown.classList.remove(\"show2\");\r\n          }\r\n        }\r\n      }\r\n    };\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <React.Fragment>\r\n        <nav className=\"main-nav\">\r\n          <div className=\"logo\">\r\n            <h3>\r\n              <Link style={{ textDecoration: \"none\", color: \"white\" }} to=\"/\">\r\n                Pathfinding Visualizer\r\n              </Link>\r\n            </h3>\r\n          </div>\r\n          <div className={this.state.sidebar ? \"menu mobile-menu\" : \"menu\"}>\r\n            <div className=\"dropdown1\">\r\n              <button\r\n                type=\"button\"\r\n                data-toggle=\"dropdown\"\r\n                aria-haspopup=\"true\"\r\n                aria-expanded=\"false\"\r\n                className=\"dropdown-button\"\r\n                onClick={() => {\r\n                  this.myFunction1();\r\n                }}\r\n              >\r\n                <span>Algorithm</span>\r\n              </button>\r\n              <div className=\"dropdown-content\" id=\"myDropdown\">\r\n                <button\r\n                  onClick={() => {\r\n                    this.selectAlgorithm(\"Visualize Dijkstra\");\r\n                  }}\r\n                >\r\n                  Dijkstra's Algorithm\r\n                </button>\r\n                <button\r\n                  onClick={() => {\r\n                    this.selectAlgorithm(\"Visualize A*\");\r\n                  }}\r\n                >\r\n                  A* Algorithm\r\n                </button>\r\n\r\n                <button\r\n                  onClick={() => {\r\n                    this.selectAlgorithm(\"Visualize Greedy BFS\");\r\n                  }}\r\n                >\r\n                  Greedy Best First Search\r\n                </button>\r\n                <button\r\n                  onClick={() => {\r\n                    this.selectAlgorithm(\"Visualize BFS\");\r\n                  }}\r\n                >\r\n                  Breadth First Search\r\n                </button>\r\n                <button\r\n                  onClick={() => {\r\n                    this.selectAlgorithm(\"Visualize DFS\");\r\n                  }}\r\n                >\r\n                  Depth First Search\r\n                </button>\r\n                <button\r\n                  onClick={() => {\r\n                    this.selectAlgorithm(\"Visualize Bidirectional\");\r\n                  }}\r\n                >\r\n                  Bidirectional Search\r\n                </button>\r\n              </div>\r\n            </div>\r\n            <div className=\"dropdown2\">\r\n              <button\r\n                className=\"dropdown-button\"\r\n                onClick={() => {\r\n                  this.myFunction2();\r\n                }}\r\n              >\r\n                <span>Mazes</span>\r\n              </button>\r\n              <div className=\"dropdown-content\" id=\"myDropdown1\">\r\n                <button\r\n                  onClick={() => {\r\n                    this.generateMaze(\"Recursive Division\");\r\n                  }}\r\n                >\r\n                  Recursive Division\r\n                </button>\r\n                <button\r\n                  onClick={() => {\r\n                    this.generateMaze(\"Recursive Vertical\");\r\n                  }}\r\n                >\r\n                  Recursive Vertival Division\r\n                </button>\r\n                <button\r\n                  onClick={() => {\r\n                    this.generateMaze(\"Recursive Horizontal\");\r\n                  }}\r\n                >\r\n                  Recursive Horizontal Division\r\n                </button>\r\n                <button\r\n                  onClick={() => {\r\n                    this.generateMaze(\"Random Walls\");\r\n                  }}\r\n                >\r\n                  Random Walls\r\n                </button>\r\n              </div>\r\n            </div>\r\n\r\n            <div className=\"tutorial\">\r\n              <Link to=\"/tutorial\">Tutorials</Link>\r\n            </div>\r\n            <div className=\"dropdown3\">\r\n              <button\r\n                className=\"dropdown-button\"\r\n                onClick={() => {\r\n                  this.myFunction3();\r\n                }}\r\n              >\r\n                <span>{this.props.sidebarSpeed}</span>\r\n              </button>\r\n              <div className=\"dropdown-content\" id=\"myDropdown2\">\r\n                <button\r\n                  onClick={() => {\r\n                    this.changeSpeed(\"Slow\");\r\n                  }}\r\n                >\r\n                  Slow\r\n                </button>\r\n                <button\r\n                  onClick={() => {\r\n                    this.changeSpeed(\"Medium\");\r\n                  }}\r\n                >\r\n                  Medium\r\n                </button>\r\n                <button\r\n                  onClick={() => {\r\n                    this.changeSpeed(\"Fast\");\r\n                  }}\r\n                >\r\n                  Fast{\" \"}\r\n                </button>\r\n              </div>\r\n            </div>\r\n          </div>\r\n          <div className=\"hamburger-menu\">\r\n            <a href=\"#\" onClick={this.showSidebar}>\r\n              <FaBars></FaBars>\r\n            </a>\r\n          </div>\r\n        </nav>\r\n      </React.Fragment>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Sidebar;\r\n","import React, { Component } from \"react\";\r\nimport \"./Footer.css\";\r\n\r\nclass Footer extends Component {\r\n  clearGrid() {\r\n    if (this.props.visualizing || this.props.mazeGeneration) {\r\n      return;\r\n    }\r\n    this.props.clearGrid();\r\n    this.props.updateAlgorithmState(\"Visualize\");\r\n    this.props.updatePathState(false);\r\n    this.props.updateMazeValueState(false);\r\n    this.props.updateMazeState(\"\");\r\n    this.props.updateSidebarSpeed(\"Speed\");\r\n  }\r\n\r\n  clearPath() {\r\n    if (this.props.visualizing || this.props.mazeGeneration) {\r\n      return;\r\n    }\r\n    this.props.clearPath();\r\n    this.props.updatePathState(false);\r\n    this.props.updateMazeValueState(false);\r\n    this.props.updateSidebarSpeed(\"Speed\");\r\n  }\r\n\r\n  visualizeAlgorithm() {\r\n    if (this.props.visualizing || this.props.mazeGeneration) {\r\n      return;\r\n    }\r\n    if (this.props.pathState) {\r\n      this.props.clearGridPartially();\r\n      console.log(\"why?\");\r\n      return;\r\n    }\r\n\r\n    if (\r\n      this.props.algorithm === \"Visualize\" ||\r\n      this.props.algorithm === \"Select Algorithm!\"\r\n    ) {\r\n      this.props.updateAlgorithmState(\"Select Algorithm!\");\r\n    } else {\r\n      this.props.updatePathState(true);\r\n      console.log(this.props.algorithm);\r\n      if (this.props.algorithm === \"Visualize Dijkstra\") {\r\n        console.log(\"are u here?\");\r\n        this.props.visualizeDijkstra();\r\n      } else if (this.props.algorithm === \"Visualize A*\")\r\n        this.props.visualizeAstar();\r\n      else if (this.props.algorithm === \"Visualize Greedy BFS\")\r\n        this.props.visualizeGreedyBFS();\r\n      else if (this.props.algorithm === \"Visualize Bidirectional\")\r\n        this.props.visualizeBidirectionalBFSSearch();\r\n      else if (this.props.algorithm === \"Visualize BFS\")\r\n        this.props.visualizeBFS();\r\n      else if (this.props.algorithm === \"Visualize DFS\")\r\n        this.props.visualizeDFS();\r\n    }\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div className=\"footer\">\r\n        <button id=\"clearPath\" onClick={() => this.clearPath()}>\r\n          Clear Path\r\n        </button>\r\n        <button id=\"visualize\" onClick={() => this.visualizeAlgorithm()}>\r\n          {this.props.algorithm}\r\n        </button>\r\n        <button id=\"clearGrid\" onClick={() => this.clearGrid()}>\r\n          Clear Grid\r\n        </button>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Footer;\r\n","// TC -> O((N+E) logN ) where N is node and E Adjacent Node\r\n// Sc -> O(N) for visitedNodesInOrder\r\n\r\nexport function dijkstras(grid, startNode, finishNode) {\r\n  if (!startNode || !finishNode || startNode === finishNode) {\r\n    return false;\r\n  }\r\n\r\n  startNode.distance = 0;\r\n  let unvisitedNodes = getNodes(grid);\r\n  let visitedNodesInOrder = [];\r\n\r\n  while (unvisitedNodes.length !== 0) {\r\n    unvisitedNodes.sort((a, b) => a.distance - b.distance);\r\n    let closestNode = unvisitedNodes.shift();\r\n    if (closestNode.isWall) continue;\r\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n    updateUnvisitedNeighbours(grid, closestNode);\r\n  }\r\n}\r\n\r\nfunction updateUnvisitedNeighbours(grid, node) {\r\n  let unvisitedNeighbours = getUnvisitedNeighbours(grid, node);\r\n  for (let unvisitedNeighbour of unvisitedNeighbours) {\r\n    unvisitedNeighbour.distance = node.distance + 1;\r\n    unvisitedNeighbour.previousNode = node;\r\n  }\r\n}\r\n\r\nfunction getUnvisitedNeighbours(grid, node) {\r\n  let neighbours = [];\r\n  let { row, col } = node;\r\n  if (row !== 0) neighbours.push(grid[row - 1][col]);\r\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\r\n  if (col !== 0) neighbours.push(grid[row][col - 1]);\r\n  if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\r\n  return neighbours.filter(\r\n    (neighbour) => !neighbour.isWall && !neighbour.isVisited\r\n  );\r\n}\r\n\r\nfunction getNodes(grid) {\r\n  let nodes = [];\r\n  for (let row of grid) {\r\n    for (let node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\nexport function dijkstraNodesInShortestPathOrder(finishNode) {\r\n  let nodesInShortestPathOrder = [];\r\n  let currNode = finishNode;\r\n  while (currNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currNode);\r\n    currNode = currNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","export function BidirectionSearch(grid, startNode, finishNode) {\r\n  if (!startNode || !finishNode || startNode === finishNode) {\r\n    return false;\r\n  }\r\n  const visitedNodesInOrder = [];\r\n  let q1 = [],\r\n    q2 = [];\r\n  let dirx = [-1, 1, 0, 0];\r\n  let diry = [0, 0, -1, 1];\r\n  q1.push([startNode.row, startNode.col]);\r\n  q2.push([finishNode.row, finishNode.col]);\r\n  let table = [];\r\n\r\n  // temporary grid for tracking visited nodes for both nodes\r\n  for (let i = 0; i < grid.length; ++i) {\r\n    let tmp = [];\r\n\r\n    for (let j = 0; j < grid[0].length; ++j) tmp.push(false);\r\n\r\n    table.push(tmp);\r\n  }\r\n\r\n  // Didirectional BFS\r\n  while (q1.length || q2.length) {\r\n    const [row1, col1] = !q1.length ? [-1, -1] : q1.shift();\r\n    const [row2, col2] = !q2.length ? [-1, -1] : q2.shift();\r\n    if (isValid(grid, row1, col1)) grid[row1][col1].isVisited = true;\r\n    if (isValid(grid, row2, col2)) table[row2][col2] = true;\r\n    let newLvl = [];\r\n\r\n    for (let i = 0; i < dirx.length; ++i) {\r\n      const newRow1 = row1 + dirx[i];\r\n      const newRow2 = row2 + dirx[i];\r\n      const newCol1 = col1 + diry[i];\r\n      const newCol2 = col2 + diry[i];\r\n\r\n      // checking for intersection\r\n      if (isValid(grid, row1, col1) && isValid(grid, newRow1, newCol1)) {\r\n        if (\r\n          !grid[newRow1][newCol1].isVisited &&\r\n          !grid[newRow1][newCol1].isWall\r\n        ) {\r\n          if (table[newRow1][newCol1]) {\r\n            if (newLvl.length) visitedNodesInOrder.push(newLvl);\r\n            return [\r\n              visitedNodesInOrder,\r\n              grid[row1][col1],\r\n              grid[newRow1][newCol1],\r\n            ];\r\n          }\r\n\r\n          grid[newRow1][newCol1].isVisited = true;\r\n          grid[newRow1][newCol1].previousNode = grid[row1][col1];\r\n          q1.push([newRow1, newCol1]);\r\n          newLvl.push([newRow1, newCol1]);\r\n        }\r\n      }\r\n\r\n      // checking for intersection\r\n      if (isValid(grid, row2, col2) && isValid(grid, newRow2, newCol2)) {\r\n        if (!table[newRow2][newCol2] && !grid[newRow2][newCol2].isWall) {\r\n          if (grid[newRow2][newCol2].isVisited) {\r\n            if (newLvl.length) visitedNodesInOrder.push(newLvl);\r\n            return [\r\n              visitedNodesInOrder,\r\n              grid[newRow2][newCol2],\r\n              grid[row2][col2],\r\n            ];\r\n          }\r\n\r\n          table[newRow2][newCol2] = true;\r\n          grid[newRow2][newCol2].previousNode = grid[row2][col2];\r\n          q2.push([newRow2, newCol2]);\r\n          newLvl.push([newRow2, newCol2]);\r\n        }\r\n      }\r\n    }\r\n\r\n    visitedNodesInOrder.push(newLvl);\r\n  }\r\n\r\n  return [\r\n    visitedNodesInOrder,\r\n    grid[startNode.row][startNode.col],\r\n    grid[finishNode.row][finishNode.col],\r\n  ];\r\n}\r\n\r\nfunction isValid(grid, row, col) {\r\n  return row < 0 || row >= grid.length || col < 0 || col >= grid[0].length\r\n    ? false\r\n    : true;\r\n}\r\n\r\nexport function BSNodesInShortestPathOrder(grid, startNode, finishNode) {\r\n  let nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode != null) {\r\n    nodesInShortestPathOrder.push(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n\r\n  // console.log(nodesInShortestPathOrder.length);\r\n  // nodesInShortestPathOrder.reverse();\r\n  currentNode = startNode;\r\n  while (currentNode != null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","export function dfs(grid, startNode, finishNode) {\r\n  if (!startNode || !finishNode || startNode === finishNode) {\r\n    return;\r\n  }\r\n  let visitedNodesInOrder = [];\r\n  let row = startNode.row;\r\n  let col = startNode.col;\r\n  let finishCol = finishNode.col;\r\n  let finishRow = finishNode.row;\r\n  depthFirstSearch(\r\n    grid,\r\n    row,\r\n    col,\r\n    finishRow,\r\n    finishCol,\r\n    visitedNodesInOrder,\r\n    finishNode\r\n  );\r\n  return visitedNodesInOrder;\r\n}\r\n\r\nfunction depthFirstSearch(\r\n  grid,\r\n  row,\r\n  col,\r\n  finishRow,\r\n  finishCol,\r\n  visitedNodesInOrder,\r\n  finishNode\r\n) {\r\n  let node = grid[row][col];\r\n  node.isVisited = true;\r\n  if (node === finishNode) return;\r\n  visitedNodesInOrder.push(node);\r\n  let dirx = [-1, 0, 1, 0];\r\n  let diry = [0, 1, 0, -1];\r\n\r\n  for (\r\n    let i = 0;\r\n    i < dirx.length && !grid[finishRow][finishCol].isVisited;\r\n    ++i\r\n  ) {\r\n    const newRow = row + dirx[i];\r\n    const newCol = col + diry[i];\r\n\r\n    if (\r\n      newRow >= 0 &&\r\n      newRow < grid.length &&\r\n      newCol >= 0 &&\r\n      newCol < grid[0].length &&\r\n      !grid[newRow][newCol].isVisited &&\r\n      !grid[newRow][newCol].isWall\r\n    ) {\r\n      grid[newRow][newCol].previousNode = node;\r\n      depthFirstSearch(\r\n        grid,\r\n        newRow,\r\n        newCol,\r\n        finishRow,\r\n        finishCol,\r\n        visitedNodesInOrder,\r\n        finishNode\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nexport function DFSNodesInShortestPathOrder(finishNode) {\r\n  let nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","export function bfs(grid, startNode, finishNode) {\r\n  if (!startNode || !finishNode || startNode === finishNode) {\r\n    return;\r\n  }\r\n  let unvisitedNodes = [];\r\n  let visitedNodesInOrder = [];\r\n  unvisitedNodes.push(startNode);\r\n  while (unvisitedNodes.length !== 0) {\r\n    let closestNode = unvisitedNodes.shift();\r\n    if (closestNode.isWall) continue;\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n    visitedNodesInOrder.push(closestNode);\r\n    closestNode.isVisited = true;\r\n    let unvisitedNeighbours = getUnvisitedNeighbours(closestNode, grid);\r\n    for (let unvisitedNeighbour of unvisitedNeighbours) {\r\n      unvisitedNeighbour.previousNode = closestNode;\r\n      if (neighbourNotInUnvisitedNodes(unvisitedNeighbour, unvisitedNodes)) {\r\n        unvisitedNodes.push(unvisitedNeighbour);\r\n      }\r\n    }\r\n  }\r\n  return visitedNodesInOrder;\r\n}\r\n\r\nfunction getUnvisitedNeighbours(node, grid) {\r\n  let neighbours = [];\r\n  let { row, col } = node;\r\n  if (row !== 0) neighbours.push(grid[row - 1][col]);\r\n  if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\r\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\r\n  if (col !== 0) neighbours.push(grid[row][col - 1]);\r\n  return neighbours.filter(\r\n    (neighbour) => !neighbour.isWall && !neighbour.isVisited\r\n  );\r\n}\r\n\r\nfunction neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\r\n  for (let node of unvisitedNodes) {\r\n    if (node.row === neighbour.row && node.col === neighbour.col) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nexport function BFSNodesInShortestPathOrder(finishNode) {\r\n  let nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","export function Astar(grid, startNode, finishNode) {\r\n  if (!startNode || !finishNode || startNode === finishNode) {\r\n    return;\r\n  }\r\n  startNode.distance = 0;\r\n  let visitedNodesInOrder = [];\r\n  let unvisitedNodes = [];\r\n  unvisitedNodes.push(startNode);\r\n\r\n  while (unvisitedNodes.length !== 0) {\r\n    unvisitedNodes.sort((x, y) => x.totalDistance - y.totalDistance);\r\n    let closestNode = unvisitedNodes.shift();\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n\r\n    let neighbours = getNeighbours(grid, closestNode);\r\n    for (let neighbour of neighbours) {\r\n      let distance = closestNode.distance + 1;\r\n\r\n      if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes)) {\r\n        unvisitedNodes.unshift(neighbour);\r\n        neighbour.distance = distance;\r\n        neighbour.totalDistance =\r\n          distance + manhattenDistance(neighbour, finishNode);\r\n        neighbour.previousNode = closestNode;\r\n      } else if (distance < neighbour.distance) {\r\n        neighbour.distance = distance;\r\n        neighbour.totalDistance =\r\n          distance + manhattenDistance(neighbour, finishNode);\r\n        neighbour.previousNode = closestNode;\r\n      }\r\n    }\r\n  }\r\n  return visitedNodesInOrder;\r\n}\r\n\r\nfunction manhattenDistance(node, finishNode) {\r\n  let x = Math.abs(node.row - finishNode.row);\r\n  let y = Math.abs(node.col - finishNode.col);\r\n  return x + y;\r\n}\r\n\r\nfunction getNeighbours(grid, node) {\r\n  let neighbours = [];\r\n  let { row, col } = node;\r\n  if (row !== 0) neighbours.push(grid[row - 1][col]);\r\n  if (col !== 0) neighbours.push(grid[row][col - 1]);\r\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\r\n  if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\r\n\r\n  return neighbours.filter(\r\n    (neighbour) => !neighbour.isWall && !neighbour.isVisited\r\n  );\r\n}\r\n\r\nfunction neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\r\n  for (let node of unvisitedNodes) {\r\n    if (node.row === neighbour.row && node.col === neighbour.col) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n","export function GreedyBFS(grid, startNode, finishNode) {\r\n  if (!startNode || !finishNode || startNode === finishNode) {\r\n    return;\r\n  }\r\n  startNode.distance = 0;\r\n  let visitedNodesInOrder = [];\r\n  let unvisitedNodes = [];\r\n  unvisitedNodes.push(startNode);\r\n\r\n  while (unvisitedNodes.length !== 0) {\r\n    unvisitedNodes.sort((x, y) => x.totalDistance - y.totalDistance);\r\n    let closestNode = unvisitedNodes.shift();\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n\r\n    let neighbours = getNeighbours(grid, closestNode);\r\n    for (let neighbour of neighbours) {\r\n      let distance = closestNode.distance + 1;\r\n\r\n      if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes)) {\r\n        unvisitedNodes.unshift(neighbour);\r\n        neighbour.distance = distance;\r\n        neighbour.totalDistance = euclideanDistance(neighbour, finishNode);\r\n        neighbour.previousNode = closestNode;\r\n      } else if (distance < neighbour.distance) {\r\n        neighbour.distance = distance;\r\n        neighbour.totalDistance = euclideanDistance(neighbour, finishNode);\r\n        neighbour.previousNode = closestNode;\r\n      }\r\n    }\r\n  }\r\n  return visitedNodesInOrder;\r\n}\r\n\r\nfunction euclideanDistance(node, finishNode) {\r\n  let x = Math.abs(finishNode.row - node.row);\r\n  let y = Math.abs(finishNode.col - node.col);\r\n  return Math.sqrt(x * x + y * y);\r\n}\r\n\r\nfunction getNeighbours(grid, node) {\r\n  let neighbours = [];\r\n  let { row, col } = node;\r\n  if (row !== 0) neighbours.push(grid[row - 1][col]);\r\n  if (col !== 0) neighbours.push(grid[row][col - 1]);\r\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\r\n  if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\r\n\r\n  return neighbours.filter(\r\n    (neighbour) => !neighbour.isWall && !neighbour.isVisited\r\n  );\r\n}\r\n\r\nfunction neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\r\n  for (let node of unvisitedNodes) {\r\n    if (node.row === neighbour.row && node.col === neighbour.col) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n","export function RecursiveDivision(grid, startNode, finishNode) {\r\n  if (!startNode || !finishNode || startNode === finishNode) {\r\n    return;\r\n  }\r\n\r\n  let walls = [];\r\n  for (let i = 0; i < grid[0].length; i++) {\r\n    if (grid[0][i] !== startNode && grid[0][i] !== finishNode) {\r\n      walls.push([0, i]);\r\n    }\r\n  }\r\n  for (let i = 0; i < grid.length; i++) {\r\n    if (\r\n      grid[i][grid[0].length - 1] !== startNode &&\r\n      grid[i][grid[0].length - 1] !== finishNode\r\n    ) {\r\n      walls.push([i, grid[0].length - 1]);\r\n    }\r\n  }\r\n  for (let i = grid[0].length - 1; i >= 0; i--) {\r\n    if (\r\n      grid[grid.length - 1][i] !== startNode &&\r\n      grid[grid.length - 1][i] !== finishNode\r\n    ) {\r\n      walls.push([grid.length - 1, i]);\r\n    }\r\n  }\r\n  for (let i = grid.length - 1; i >= 0; i--) {\r\n    if (grid[i][0] !== startNode && grid[i][0] !== finishNode) {\r\n      walls.push([i, 0]);\r\n    }\r\n  }\r\n\r\n  let horizontal = scale(grid[0].length - 1);\r\n  let vertical = scale(grid.length);\r\n  recursiveWalls(vertical, horizontal, grid, startNode, finishNode, walls);\r\n  return walls;\r\n}\r\n\r\nfunction recursiveWalls(\r\n  vertical,\r\n  horizontal,\r\n  grid,\r\n  startNode,\r\n  finishNode,\r\n  walls\r\n) {\r\n  if (vertical.length < 2 || horizontal.length < 2) {\r\n    return;\r\n  }\r\n  let dir;\r\n  let num;\r\n  if (vertical.length < horizontal.length) {\r\n    dir = 0; //Horizontal\r\n    num = getRandomIndex(horizontal);\r\n  }\r\n  if (vertical.length >= horizontal.length) {\r\n    dir = 1; //Vertical\r\n    num = getRandomIndex(vertical);\r\n  }\r\n\r\n  if (dir === 0) {\r\n    addIntoWalls(dir, num, vertical, horizontal, startNode, finishNode, walls);\r\n    recursiveWalls(\r\n      vertical,\r\n      horizontal.slice(0, horizontal.indexOf(num)),\r\n      grid,\r\n      startNode,\r\n      finishNode,\r\n      walls\r\n    );\r\n    recursiveWalls(\r\n      vertical,\r\n      horizontal.slice(horizontal.indexOf(num) + 1),\r\n      grid,\r\n      startNode,\r\n      finishNode,\r\n      walls\r\n    );\r\n  } else {\r\n    addIntoWalls(dir, num, vertical, horizontal, startNode, finishNode, walls);\r\n    recursiveWalls(\r\n      vertical.slice(0, vertical.indexOf(num)),\r\n      horizontal,\r\n      grid,\r\n      startNode,\r\n      finishNode,\r\n      walls\r\n    );\r\n    recursiveWalls(\r\n      vertical.slice(vertical.indexOf(num) + 1),\r\n      horizontal,\r\n      grid,\r\n      startNode,\r\n      finishNode,\r\n      walls\r\n    );\r\n  }\r\n}\r\n\r\nfunction addIntoWalls(\r\n  dir,\r\n  num,\r\n  vertical,\r\n  horizontal,\r\n  startNode,\r\n  finishNode,\r\n  walls\r\n) {\r\n  let removeRandomNode = false;\r\n  let tempWalls = [];\r\n  if (dir === 0) {\r\n    if (vertical.length === 2) return;\r\n    for (let temp of vertical) {\r\n      if (\r\n        (temp === startNode.row && num === startNode.col) ||\r\n        (temp === finishNode.row && num === finishNode.col)\r\n      ) {\r\n        removeRandomNode = true;\r\n        continue;\r\n      }\r\n      tempWalls.push([temp, num]);\r\n    }\r\n  } else {\r\n    if (horizontal.length === 2) return;\r\n    for (let temp of horizontal) {\r\n      if (\r\n        (num === startNode.row && temp === startNode.col) ||\r\n        (num === finishNode.row && temp === finishNode.col)\r\n      ) {\r\n        removeRandomNode = true;\r\n        continue;\r\n      }\r\n      tempWalls.push([num, temp]);\r\n    }\r\n  }\r\n  if (!removeRandomNode) {\r\n    tempWalls.splice(randomNumbers(tempWalls.length), 1);\r\n  }\r\n  for (let wall of tempWalls) {\r\n    walls.push(wall);\r\n  }\r\n}\r\nfunction randomNumbers(len) {\r\n  let random =\r\n    Math.floor((Math.random() * len) / 2) +\r\n    Math.floor((Math.random() * len) / 2);\r\n  if (random % 2 !== 0) {\r\n    if (random === len) {\r\n      random -= 1;\r\n    } else {\r\n      random += 1;\r\n    }\r\n  }\r\n  return random;\r\n}\r\n\r\nfunction scale(len) {\r\n  let ans = [];\r\n  for (let i = 1; i < len; i++) {\r\n    ans.push(i);\r\n  }\r\n  return ans;\r\n}\r\n\r\nfunction getRandomIndex(arr) {\r\n  let len = arr.length - 1;\r\n  let random =\r\n    Math.floor((Math.random() * len) / 2) +\r\n    Math.floor((Math.random() * len) / 2);\r\n  if (random % 2 === 0) {\r\n    if (random === len) {\r\n      random -= 1;\r\n    } else {\r\n      random += 1;\r\n    }\r\n  }\r\n  return arr[random];\r\n}\r\n","export function RecursiveHorizontal(grid, startNode, finishNode) {\r\n  if (!startNode || !finishNode || startNode === finishNode) {\r\n    return;\r\n  }\r\n\r\n  let walls = [];\r\n  for (let i = 0; i < grid[0].length; i++) {\r\n    if (grid[0][i] !== startNode && grid[0][i] !== finishNode) {\r\n      walls.push([0, i]);\r\n    }\r\n  }\r\n  for (let i = 0; i < grid.length; i++) {\r\n    if (\r\n      grid[i][grid[0].length - 1] !== startNode &&\r\n      grid[i][grid[0].length - 1] !== finishNode\r\n    ) {\r\n      walls.push([i, grid[0].length - 1]);\r\n    }\r\n  }\r\n  for (let i = grid[0].length - 1; i >= 0; i--) {\r\n    if (\r\n      grid[grid.length - 1][i] !== startNode &&\r\n      grid[grid.length - 1][i] !== finishNode\r\n    ) {\r\n      walls.push([grid.length - 1, i]);\r\n    }\r\n  }\r\n  for (let i = grid.length - 1; i >= 0; i--) {\r\n    if (grid[i][0] !== startNode && grid[i][0] !== finishNode) {\r\n      walls.push([i, 0]);\r\n    }\r\n  }\r\n\r\n  let horizontal = scale(grid[0].length - 1);\r\n  let vertical = scale(grid.length);\r\n  recursiveWalls(vertical, horizontal, grid, startNode, finishNode, walls);\r\n  return walls;\r\n}\r\n\r\nfunction recursiveWalls(\r\n  vertical,\r\n  horizontal,\r\n  grid,\r\n  startNode,\r\n  finishNode,\r\n  walls\r\n) {\r\n  if (vertical.length < 2) {\r\n    return;\r\n  }\r\n\r\n  let breakRow = Math.floor(Math.random() * 2);\r\n  for (let num of vertical) {\r\n    if (breakRow === 0 && num % 2 !== 0) {\r\n      addIntoWalls(num, horizontal, startNode, finishNode, walls);\r\n    }\r\n    if (breakRow === 1 && num % 2 === 0) {\r\n      addIntoWalls(num, horizontal, startNode, finishNode, walls);\r\n    }\r\n  }\r\n}\r\n\r\nfunction addIntoWalls(num, horizontal, startNode, finishNode, walls) {\r\n  let removeRandomNode = false;\r\n  let tempWalls = [];\r\n\r\n  if (horizontal.length === 2) return;\r\n  for (let temp of horizontal) {\r\n    if (\r\n      (num === startNode.row && temp === startNode.col) ||\r\n      (num === finishNode.row && temp === finishNode.col)\r\n    ) {\r\n      removeRandomNode = true;\r\n      continue;\r\n    }\r\n    tempWalls.push([num, temp]);\r\n  }\r\n\r\n  if (!removeRandomNode) {\r\n    tempWalls.splice(Math.floor(Math.random() * tempWalls.length), 1);\r\n  }\r\n  for (let wall of tempWalls) {\r\n    walls.push(wall);\r\n  }\r\n}\r\n\r\nfunction scale(len) {\r\n  let ans = [];\r\n  for (let i = 1; i < len; i++) {\r\n    ans.push(i);\r\n  }\r\n  return ans;\r\n}\r\n","export function RecursiveVertical(grid, startNode, finishNode) {\r\n  if (!startNode || !finishNode || startNode === finishNode) {\r\n    return;\r\n  }\r\n\r\n  let walls = [];\r\n  for (let i = 0; i < grid[0].length; i++) {\r\n    if (grid[0][i] !== startNode && grid[0][i] !== finishNode) {\r\n      walls.push([0, i]);\r\n    }\r\n  }\r\n  for (let i = 0; i < grid.length; i++) {\r\n    if (\r\n      grid[i][grid[0].length - 1] !== startNode &&\r\n      grid[i][grid[0].length - 1] !== finishNode\r\n    ) {\r\n      walls.push([i, grid[0].length - 1]);\r\n    }\r\n  }\r\n  for (let i = grid[0].length - 1; i >= 0; i--) {\r\n    if (\r\n      grid[grid.length - 1][i] !== startNode &&\r\n      grid[grid.length - 1][i] !== finishNode\r\n    ) {\r\n      walls.push([grid.length - 1, i]);\r\n    }\r\n  }\r\n  for (let i = grid.length - 1; i >= 0; i--) {\r\n    if (grid[i][0] !== startNode && grid[i][0] !== finishNode) {\r\n      walls.push([i, 0]);\r\n    }\r\n  }\r\n\r\n  let horizontal = scale(grid[0].length - 1);\r\n  let vertical = scale(grid.length);\r\n  recursiveWalls(vertical, horizontal, grid, startNode, finishNode, walls);\r\n  return walls;\r\n}\r\n\r\nfunction recursiveWalls(\r\n  vertical,\r\n  horizontal,\r\n  grid,\r\n  startNode,\r\n  finishNode,\r\n  walls\r\n) {\r\n  if (horizontal.length < 2) {\r\n    return;\r\n  }\r\n\r\n  let breakRow = Math.floor(Math.random() * 2);\r\n  for (let num of horizontal) {\r\n    if (breakRow === 0 && num % 2 !== 0) {\r\n      addIntoWalls(num, vertical, startNode, finishNode, walls);\r\n    }\r\n    if (breakRow === 1 && num % 2 === 0) {\r\n      addIntoWalls(num, vertical, startNode, finishNode, walls);\r\n    }\r\n  }\r\n}\r\n\r\nfunction addIntoWalls(num, vertical, startNode, finishNode, walls) {\r\n  let removeRandomNode = false;\r\n  let tempWalls = [];\r\n\r\n  if (vertical.length === 2) return;\r\n  for (let temp of vertical) {\r\n    if (\r\n      (temp === startNode.row && num === startNode.col) ||\r\n      (temp === finishNode.row && num === finishNode.col)\r\n    ) {\r\n      removeRandomNode = true;\r\n      continue;\r\n    }\r\n    tempWalls.push([temp, num]);\r\n  }\r\n\r\n  if (!removeRandomNode) {\r\n    tempWalls.splice(Math.floor(Math.random() * tempWalls.length), 1);\r\n  }\r\n  for (let wall of tempWalls) {\r\n    walls.push(wall);\r\n  }\r\n}\r\n\r\nfunction scale(len) {\r\n  let ans = [];\r\n  for (let i = 1; i < len; i++) {\r\n    ans.push(i);\r\n  }\r\n  return ans;\r\n}\r\n","export default __webpack_public_path__ + \"static/media/select_algorithm.e3847a79.mp4\";","export default __webpack_public_path__ + \"static/media/select_mazes.3f62dec7.mp4\";","export default __webpack_public_path__ + \"static/media/select_speed.05c9ff89.mp4\";","export default __webpack_public_path__ + \"static/media/visualize.d8f13dee.mp4\";","export default __webpack_public_path__ + \"static/media/clearGrid.b35036f2.mp4\";","export default __webpack_public_path__ + \"static/media/clearPath.b3e59a76.mp4\";","export default __webpack_public_path__ + \"static/media/drawMaze.0172c601.mp4\";","export default __webpack_public_path__ + \"static/media/createWalls.8c85f28a.mp4\";","import React, { Component } from \"react\";\r\nimport video1 from \"./select_algorithm.mp4\";\r\nimport video2 from \"./select_mazes.mp4\";\r\nimport video3 from \"./select_speed.mp4\";\r\nimport video4 from \"./visualize.mp4\";\r\nimport video5 from \"./clearGrid.mp4\";\r\nimport video6 from \"./clearPath.mp4\";\r\nimport video7 from \"./drawMaze.mp4\";\r\nimport video8 from \"./createWalls.mp4\";\r\nimport \"./Tutorial.css\";\r\nclass Tutorial extends Component {\r\n  // This below function gets executed when you click on videos.\r\n  componentDidMount() {\r\n    var video = document.querySelectorAll(\"video\");\r\n    video.forEach((play) =>\r\n      play.addEventListener(\"click\", () => {\r\n        play.classList.toggle(\"active\");\r\n        if (play.paused) {\r\n          play.play();\r\n        } else {\r\n          play.pause();\r\n          play.currentTime = 0;\r\n        }\r\n      })\r\n    );\r\n  }\r\n  render() {\r\n    return (\r\n      <React.Fragment>\r\n        <div className=\"container\">\r\n          <div className=\"heading\">Pathfinding Visualizer Tutorial</div>\r\n          <div className=\"video-container\">\r\n            <div className=\"video\">\r\n              <video src={video1}></video>\r\n              <div className=\"content\">\r\n                <h2>Select Algorithm</h2>\r\n                <p>\r\n                  Choose Algorithms of your choice before visualizing for\r\n                  finding the shortest path\r\n                </p>\r\n              </div>\r\n            </div>\r\n            <div className=\"video\">\r\n              <video src={video2}></video>\r\n              <div className=\"content\">\r\n                <h2>Select Mazes</h2>\r\n                <p>\r\n                  Choose Different Mazes And Patterns to add some obstacles or\r\n                  walls in between the source and destination.\r\n                </p>\r\n              </div>\r\n            </div>\r\n            <div className=\"video\">\r\n              <video src={video3}></video>\r\n              <div className=\"content\">\r\n                <h2>Select Speed</h2>\r\n                <p>\r\n                  Your increase or decrease the speed of visualizing to get the\r\n                  proper understanding of how visualization is happening behind\r\n                  the scenes.\r\n                </p>\r\n              </div>\r\n            </div>\r\n            <div className=\"video\">\r\n              <video src={video4}></video>\r\n              <div className=\"content\">\r\n                <h2>Visualize</h2>\r\n                <p>\r\n                  After selecting the algorithm, mazes and speed you can now\r\n                  click on Visualize button to start visualizing the selected\r\n                  algorithm.\r\n                </p>\r\n              </div>\r\n            </div>\r\n            <div className=\"video\">\r\n              <video src={video5}></video>\r\n              <div className=\"content\">\r\n                <h2>Clear Grid</h2>\r\n                <p>Clear Grid button will reset the whole application.</p>\r\n              </div>\r\n            </div>\r\n            <div className=\"video\">\r\n              <video src={video6}></video>\r\n              <div className=\"content\">\r\n                <h2>Clear Path</h2>\r\n                <p>\r\n                  Clear Path button will clear the board or grid without\r\n                  changing any options.\r\n                </p>\r\n              </div>\r\n            </div>\r\n            <div className=\"video\">\r\n              <video src={video7}></video>\r\n              <div className=\"content\">\r\n                <h2>Draw Mazes</h2>\r\n                <p>\r\n                  As soon as you click on any of the mazes it will start\r\n                  appearing on the grid.\r\n                </p>\r\n              </div>\r\n            </div>\r\n            <div className=\"video\">\r\n              <video src={video8}></video>\r\n              <div className=\"content\">\r\n                <h2>Create Walls</h2>\r\n                <p>\r\n                  You can create walls on grid by pressing the mouse button\r\n                  while hover on the grid.\r\n                </p>\r\n              </div>\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </React.Fragment>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Tutorial;\r\n","import React, { Component } from \"react\";\r\nimport \"./Visualizer.css\";\r\nimport Node from \"./Node\";\r\nimport Sidebar from \"./Sidebar\";\r\nimport Footer from \"./Footer\";\r\nimport { BrowserRouter as Router, Route, Switch, Link } from \"react-router-dom\";\r\n//Algorithms\r\nimport { dijkstras } from \"../Algorithms/dijkstras\";\r\n\r\nimport {\r\n  BidirectionSearch,\r\n  BSNodesInShortestPathOrder,\r\n} from \"../Algorithms/BidirectionSearch\";\r\n\r\nimport { dfs } from \"../Algorithms/depthFirstSearch\";\r\n\r\nimport { bfs } from \"../Algorithms/breadthFirstSearch\";\r\n\r\nimport { Astar } from \"../Algorithms/Astar\";\r\nimport { GreedyBFS } from \"../Algorithms/GreedyBFS\";\r\n\r\n//Mazes And Patterns\r\nimport { RandomWalls } from \"../MazesAndPatterns/RandomWalls\";\r\nimport { RecursiveDivision } from \"../MazesAndPatterns/RecursiveDivision\";\r\nimport { RecursiveHorizontal } from \"../MazesAndPatterns/RecursiveHorizontal\";\r\nimport { RecursiveVertical } from \"../MazesAndPatterns/RecursiveVertical\";\r\nimport Tutorial from \"./Tutorial\";\r\n\r\nconst initialNum = getInitialNum(window.innerWidth, window.innerHeight);\r\nconst initialNumRows = initialNum[0];\r\nconst initialNumCols = initialNum[1];\r\n\r\nlet startAndfinish = getStartFinishNode(initialNumRows - 9, initialNumCols);\r\nconst startNodeRow = startAndfinish[0];\r\nconst startNodeCol = startAndfinish[1];\r\nconst finishNodeRow = startAndfinish[2];\r\nconst finishNodeCol = startAndfinish[3];\r\n\r\nclass Visualizer extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      algorithm: \"Visualize\",\r\n      grid: [],\r\n      mouseIsPressed: false,\r\n      visualizing: false,\r\n      mazeGeneration: false,\r\n      width: window.innerWidth,\r\n      height: window.innerHeight,\r\n      numRows: initialNumRows,\r\n      numCols: initialNumCols,\r\n      speed: 10,\r\n      mazeSpeed: 10,\r\n      maze: \"\",\r\n      pathState: false,\r\n      mazeState: false,\r\n      sidebarSpeed: \"Speed\",\r\n    };\r\n  }\r\n\r\n  nodesInShortestPathOrder = (finishNode) => {\r\n    let nodesInShortestPathOrder = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode != null) {\r\n      nodesInShortestPathOrder.unshift(currentNode);\r\n      currentNode = currentNode.previousNode;\r\n    }\r\n    return nodesInShortestPathOrder;\r\n  };\r\n\r\n  animateShortestPath = (nodesInShortestPathOrder, visitedNodesInOrder) => {\r\n    if (nodesInShortestPathOrder.length === 1)\r\n      this.setState({ visualizing: false });\r\n    for (let i = 1; i < nodesInShortestPathOrder.length; i++) {\r\n      if (i === nodesInShortestPathOrder.length - 1) {\r\n        setTimeout(() => {\r\n          let newGrid = updateNodesForRender(\r\n            this.state.grid,\r\n            nodesInShortestPathOrder,\r\n            visitedNodesInOrder\r\n          );\r\n          this.setState({ grid: newGrid, visualizing: false });\r\n        }, i * (3 * this.state.speed));\r\n        return;\r\n      }\r\n      let node = nodesInShortestPathOrder[i];\r\n      setTimeout(() => {\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node-shortest-path\";\r\n      }, i * (3 * this.state.speed));\r\n    }\r\n  };\r\n\r\n  animateAlgorithm = (visitedNodesInOrder, nodesInShortestPathOrder) => {\r\n    let newGrid = this.state.grid.slice();\r\n    for (let row of newGrid) {\r\n      for (let node of row) {\r\n        let newNode = {\r\n          ...node,\r\n          isVisited: false,\r\n        };\r\n        newGrid[node.row][node.col] = newNode;\r\n      }\r\n    }\r\n    this.setState({ grid: newGrid });\r\n    for (let i = 1; i <= visitedNodesInOrder.length; i++) {\r\n      let node = visitedNodesInOrder[i];\r\n      if (i === visitedNodesInOrder.length) {\r\n        setTimeout(() => {\r\n          this.animateShortestPath(\r\n            nodesInShortestPathOrder,\r\n            visitedNodesInOrder\r\n          );\r\n        }, i * this.state.speed);\r\n        return;\r\n      }\r\n      setTimeout(() => {\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node-visited\";\r\n      }, i * this.state.speed);\r\n    }\r\n  };\r\n\r\n  animateMaze = (walls) => {\r\n    for (let i = 0; i <= walls.length; i++) {\r\n      if (i === walls.length) {\r\n        setTimeout(() => {\r\n          this.clearGrid();\r\n          let newGrid = newGridWithMaze(this.state.grid, walls);\r\n          this.setState({ grid: newGrid, mazeGeneration: false });\r\n        }, i * this.state.mazeSpeed);\r\n        return;\r\n      }\r\n      let wall = walls[i];\r\n      let node = this.state.grid[wall[0]][wall[1]];\r\n      setTimeout(() => {\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node-wall\";\r\n      }, i * this.state.mazeSpeed);\r\n    }\r\n  };\r\n\r\n  generateRandomWalls() {\r\n    if (this.state.visualizing || this.state.mazeGeneration) {\r\n      return;\r\n    }\r\n    this.setState({ mazeGeneration: true });\r\n    setTimeout(() => {\r\n      const { grid } = this.state;\r\n      const startNode = grid[startNodeRow][startNodeCol];\r\n      const finishNode = grid[finishNodeRow][finishNodeCol];\r\n      const walls = RandomWalls(grid, startNode, finishNode, 29, 55);\r\n      this.animateMaze(walls);\r\n    }, this.state.mazeSpeed);\r\n  }\r\n\r\n  generateRecursiveDivision() {\r\n    if (this.state.visualizing || this.state.mazeGeneration) {\r\n      return;\r\n    }\r\n    this.setState({ mazeGeneration: true });\r\n    setTimeout(() => {\r\n      const { grid } = this.state;\r\n      const startNode = grid[startNodeRow][startNodeCol];\r\n      const finishNode = grid[finishNodeRow][finishNodeCol];\r\n      const walls = RecursiveDivision(grid, startNode, finishNode);\r\n      this.animateMaze(walls);\r\n    }, this.state.mazeSpeed);\r\n  }\r\n\r\n  generateRecursiveHorizontal() {\r\n    if (this.state.visualizing || this.state.mazeGeneration) {\r\n      return;\r\n    }\r\n    this.setState({ mazeGeneration: true });\r\n    setTimeout(() => {\r\n      const { grid } = this.state;\r\n      const startNode = grid[startNodeRow][startNodeCol];\r\n      const finishNode = grid[finishNodeRow][finishNodeCol];\r\n      const walls = RecursiveHorizontal(grid, startNode, finishNode);\r\n      this.animateMaze(walls);\r\n    }, this.state.mazeSpeed);\r\n  }\r\n  generateRecursiveVertical() {\r\n    if (this.state.visualizing || this.state.mazeGeneration) {\r\n      return;\r\n    }\r\n    this.setState({ mazeGeneration: true });\r\n    setTimeout(() => {\r\n      const { grid } = this.state;\r\n      const startNode = grid[startNodeRow][startNodeCol];\r\n      const finishNode = grid[finishNodeRow][finishNodeCol];\r\n      const walls = RecursiveVertical(grid, startNode, finishNode);\r\n      this.animateMaze(walls);\r\n    }, this.state.mazeSpeed);\r\n  }\r\n\r\n  // Updating states section\r\n  updateDimensions = () => {\r\n    this.setState({\r\n      width: window.innerWidth,\r\n      height: window.innerHeight,\r\n    });\r\n  };\r\n\r\n  updateSpeed(pathSpeed, mazeSpeed) {\r\n    this.setState({ speed: pathSpeed, mazeSpeed: mazeSpeed });\r\n  }\r\n\r\n  updateAlgorithmState(selection) {\r\n    this.setState({ algorithm: selection });\r\n  }\r\n  updatePathState(value) {\r\n    this.setState({ pathState: value });\r\n  }\r\n  updateMazeValueState(value) {\r\n    this.setState({ mazeState: value }); // maze boolean value state\r\n  }\r\n  updateSidebarSpeed(selection) {\r\n    this.setState({ sidebarSpeed: selection });\r\n  }\r\n  updateMazeState(selection) {\r\n    this.setState({ maze: selection });\r\n  }\r\n\r\n  // Mouse Handling Events\r\n  handleMouseDown(row, col) {\r\n    const newGrid = getNewGridWithWalls(this.state.grid, row, col);\r\n    this.setState({ grid: newGrid, mouseIsPressed: true });\r\n  }\r\n\r\n  handleMouseEnter(row, col) {\r\n    if (this.state.mouseIsPressed) {\r\n      const newGrid = getNewGridWithWalls(this.state.grid, row, col);\r\n      this.setState({ grid: newGrid, mouseIsPressed: true });\r\n    }\r\n  }\r\n\r\n  handleMouseUp() {\r\n    this.setState({ mouseIsPressed: false });\r\n  }\r\n\r\n  componentDidMount() {\r\n    window.addEventListener(\"resize\", this.updateDimensions);\r\n    const grid = getInitialGrid(this.state.numRows, this.state.numCols);\r\n    this.setState({ grid });\r\n  }\r\n\r\n  clearGrid() {\r\n    if (this.state.visualizing || this.state.mazeGeneration) {\r\n      return;\r\n    }\r\n    for (let row = 0; row < this.state.grid.length; row++) {\r\n      for (let col = 0; col < this.state.grid[0].length; col++) {\r\n        if (\r\n          !(\r\n            (row === startNodeRow && col === startNodeCol) ||\r\n            (row === finishNodeRow && col === finishNodeCol)\r\n          )\r\n        ) {\r\n          document.getElementById(`node-${row}-${col}`).className = \"node\";\r\n        }\r\n      }\r\n    }\r\n    const newGrid = getInitialGrid(this.state.numRows, this.state.numCols);\r\n    this.setState({\r\n      grid: newGrid,\r\n      visualizing: false,\r\n      mazeGeneration: false,\r\n    });\r\n  }\r\n\r\n  clearPath() {\r\n    if (this.state.visualizing || this.state.mazeGeneration) {\r\n      return;\r\n    }\r\n    for (let row = 0; row < this.state.grid.length; row++) {\r\n      for (let col = 0; col < this.state.grid[0].length; col++) {\r\n        if (\r\n          document.getElementById(`node-${row}-${col}`).className ===\r\n          \"node node-shortest-path\"\r\n        ) {\r\n          document.getElementById(`node-${row}-${col}`).className = \"node\";\r\n        }\r\n      }\r\n    }\r\n    const newGrid = getGridWithoutPath(this.state.grid);\r\n    this.setState({\r\n      grid: newGrid,\r\n      visualizing: false,\r\n      mazeGeneration: false,\r\n    });\r\n  }\r\n  clearGridPartially() {\r\n    if (this.props.visualizing || this.props.mazeGeneration) {\r\n      return;\r\n    }\r\n    this.clearGrid();\r\n    this.updateMazeValueState(false);\r\n    this.updatePathState(false);\r\n  }\r\n  // Algorithm part\r\n  visualizeDijkstra() {\r\n    if (this.state.visualizing || this.state.mazeGeneration) {\r\n      return;\r\n    }\r\n    this.setState({ visualizing: true });\r\n    setTimeout(() => {\r\n      const { grid } = this.state;\r\n      const startNode = grid[startNodeRow][startNodeCol];\r\n      const finishNode = grid[finishNodeRow][finishNodeCol];\r\n      const visitedNodesInOrder = dijkstras(grid, startNode, finishNode);\r\n      const nodesInShortestPathOrder =\r\n        this.nodesInShortestPathOrder(finishNode);\r\n      this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    }, this.state.speed);\r\n  }\r\n\r\n  visualizeBidirectionalBFSSearch() {\r\n    if (this.state.visualizing || this.state.mazeGeneration) {\r\n      return;\r\n    }\r\n    this.setState({ visualizing: true });\r\n    setTimeout(() => {\r\n      const { grid } = this.state;\r\n      let startNode = grid[startNodeRow][startNodeCol];\r\n      let finishNode = grid[finishNodeRow][finishNodeCol];\r\n      const visitedNodesOrder = BidirectionSearch(grid, startNode, finishNode);\r\n\r\n      let visitedNodesInOrder = visitedNodesOrder[0];\r\n      startNode = visitedNodesOrder[1];\r\n      finishNode = visitedNodesOrder[2];\r\n      let nodesInShortestPathOrder = BSNodesInShortestPathOrder(\r\n        this.state.grid,\r\n        startNode,\r\n        finishNode\r\n      );\r\n\r\n      this.animateBidirectionalAlgorithm(\r\n        visitedNodesInOrder,\r\n        nodesInShortestPathOrder\r\n      );\r\n    }, this.state.speed);\r\n  }\r\n\r\n  animateBidirectionalAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n    let newGrid = this.state.grid.slice();\r\n    for (let row of newGrid) {\r\n      for (let node of row) {\r\n        let newNode = {\r\n          ...node,\r\n          isVisited: false,\r\n        };\r\n        newGrid[node.row][node.col] = newNode;\r\n      }\r\n    }\r\n    this.setState({ grid: newGrid });\r\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n      if (i === visitedNodesInOrder.length) {\r\n        setTimeout(() => {\r\n          this.animateShortestPathForBS(\r\n            nodesInShortestPathOrder,\r\n            visitedNodesInOrder\r\n          );\r\n        }, i * this.state.speed);\r\n\r\n        return;\r\n      }\r\n      setTimeout(() => {\r\n        for (let j = 0; j < visitedNodesInOrder[i].length; ++j) {\r\n          const [row, col] = visitedNodesInOrder[i][j];\r\n\r\n          document.getElementById(`node-${row}-${col}`).className =\r\n            \"node node-visited\";\r\n        }\r\n      }, i * this.state.speed);\r\n    }\r\n  }\r\n\r\n  animateShortestPathForBS(nodesInShortestPathOrder, visitedNodesInOrder) {\r\n    if (nodesInShortestPathOrder.length === 1)\r\n      this.setState({ visualizing: false });\r\n    for (let i = 1; i <= nodesInShortestPathOrder.length - 1; i++) {\r\n      const node = nodesInShortestPathOrder[i];\r\n      if (i === nodesInShortestPathOrder.length - 1) {\r\n        setTimeout(() => {\r\n          let newGrid = updateNodesForRenderBS(\r\n            this.state.grid,\r\n            nodesInShortestPathOrder,\r\n            visitedNodesInOrder\r\n          );\r\n          this.setState({ grid: newGrid, visualizing: false });\r\n        }, i * (3 * this.state.speed));\r\n        return;\r\n      }\r\n\r\n      setTimeout(() => {\r\n        // coloring the found path\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node-shortest-path\";\r\n      }, i * (3 * this.state.speed));\r\n    }\r\n  }\r\n\r\n  visualizeDFS() {\r\n    if (this.state.visualizing || this.state.mazeGeneration) {\r\n      return;\r\n    }\r\n    this.setState({ visualizing: true });\r\n    setTimeout(() => {\r\n      const { grid } = this.state;\r\n      const startNode = grid[startNodeRow][startNodeCol];\r\n      const finishNode = grid[finishNodeRow][finishNodeCol];\r\n      const visitedNodesInOrder = dfs(grid, startNode, finishNode);\r\n      const nodesInShortestPathOrder =\r\n        this.nodesInShortestPathOrder(finishNode);\r\n      this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    }, this.state.speed);\r\n  }\r\n\r\n  visualizeBFS() {\r\n    if (this.state.visualizing || this.state.mazeGeneration) {\r\n      return;\r\n    }\r\n    this.setState({ visualizing: true });\r\n    setTimeout(() => {\r\n      const { grid } = this.state;\r\n      const startNode = grid[startNodeRow][startNodeCol];\r\n      const finishNode = grid[finishNodeRow][finishNodeCol];\r\n      const visitedNodesInOrder = bfs(grid, startNode, finishNode);\r\n      const nodesInShortestPathOrder =\r\n        this.nodesInShortestPathOrder(finishNode);\r\n      this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    }, this.state.speed);\r\n  }\r\n\r\n  visualizeAstar() {\r\n    if (this.state.visualizing || this.state.mazeGeneration) {\r\n      return;\r\n    }\r\n    this.setState({ visualizing: true });\r\n    setTimeout(() => {\r\n      const { grid } = this.state;\r\n      const startNode = grid[startNodeRow][startNodeCol];\r\n      const finishNode = grid[finishNodeRow][finishNodeCol];\r\n      const visitedNodesInOrder = Astar(grid, startNode, finishNode);\r\n      const nodesInShortestPathOrder =\r\n        this.nodesInShortestPathOrder(finishNode);\r\n      this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    }, this.state.speed);\r\n  }\r\n  visualizeGreedyBFS() {\r\n    if (this.state.visualizing || this.state.mazeGeneration) {\r\n      return;\r\n    }\r\n    this.setState({ visualizing: true });\r\n    setTimeout(() => {\r\n      const { grid } = this.state;\r\n      const startNode = grid[startNodeRow][startNodeCol];\r\n      const finishNode = grid[finishNodeRow][finishNodeCol];\r\n      const visitedNodesInOrder = GreedyBFS(grid, startNode, finishNode);\r\n      const nodesInShortestPathOrder =\r\n        this.nodesInShortestPathOrder(finishNode);\r\n      this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    }, this.state.speed);\r\n  }\r\n  render() {\r\n    let { grid } = this.state;\r\n    return (\r\n      <React.Fragment>\r\n        <Router>\r\n          <Sidebar\r\n            algorithm={this.state.algorithm}\r\n            maze={this.state.maze}\r\n            sidebarSpeed={this.state.sidebarSpeed}\r\n            pathState={this.state.pathState}\r\n            mazeState={this.state.mazeState}\r\n            mazeSpeed={this.state.mazeSpeed}\r\n            visualizing={this.state.visualizing}\r\n            updateAlgorithmState={this.updateAlgorithmState.bind(this)}\r\n            updateMazeValueState={this.updateMazeValueState.bind(this)}\r\n            updatePathState={this.updatePathState.bind(this)}\r\n            updateSidebarSpeed={this.updateSidebarSpeed.bind(this)}\r\n            updateMazeState={this.updateMazeState.bind(this)}\r\n            updateSpeed={this.updateSpeed.bind(this)}\r\n            clearPath={this.clearPath.bind(this)}\r\n            generateRandomWalls={this.generateRandomWalls.bind(this)}\r\n            generateRecursiveDivision={this.generateRecursiveDivision.bind(\r\n              this\r\n            )}\r\n            generateRecursiveHorizontal={this.generateRecursiveHorizontal.bind(\r\n              this\r\n            )}\r\n            generateRecursiveVertical={this.generateRecursiveVertical.bind(\r\n              this\r\n            )}\r\n            clearGridPartially={this.clearGridPartially.bind(this)}\r\n          />\r\n          <Switch>\r\n            <Route exact path=\"/tutorial\">\r\n              <Tutorial></Tutorial>\r\n            </Route>\r\n            <Route exact path=\"/\">\r\n              <div\r\n                className={\r\n                  this.state.visualizing || this.state.mazeGeneration\r\n                    ? \"visualizing-grid\"\r\n                    : \"grid\"\r\n                }\r\n              >\r\n                {grid.map((row, currRow) => {\r\n                  return (\r\n                    <div key={currRow}>\r\n                      {row.map((cell, currCell) => {\r\n                        const {\r\n                          row,\r\n                          col,\r\n                          isStart,\r\n                          isFinish,\r\n                          isVisited,\r\n                          isShortest,\r\n                          isWall,\r\n                        } = cell;\r\n                        return (\r\n                          <Node\r\n                            key={currCell}\r\n                            row={row}\r\n                            col={col}\r\n                            isStart={isStart}\r\n                            isFinish={isFinish}\r\n                            isWall={isWall}\r\n                            isVisited={isVisited}\r\n                            isShortest={isShortest}\r\n                            onMouseDown={(row, col) =>\r\n                              this.handleMouseDown(row, col)\r\n                            }\r\n                            onMouseEnter={(row, col) =>\r\n                              this.handleMouseEnter(row, col)\r\n                            }\r\n                            onMouseUp={() => this.handleMouseUp()}\r\n                            width={this.state.width}\r\n                            height={this.state.height}\r\n                            numRows={this.state.numRows}\r\n                            numCols={this.state.numCols}\r\n                          />\r\n                        );\r\n                      })}\r\n                    </div>\r\n                  );\r\n                })}\r\n              </div>\r\n              <Footer\r\n                algorithm={this.state.algorithm}\r\n                maze={this.state.maze}\r\n                sidebarSpeed={this.state.sidebarSpeed}\r\n                pathState={this.state.pathState}\r\n                mazeState={this.state.mazeState}\r\n                clearGrid={this.clearGrid.bind(this)}\r\n                visualizing={this.state.visualizing}\r\n                algorithm={this.state.algorithm}\r\n                updateAlgorithmState={this.updateAlgorithmState.bind(this)}\r\n                updateMazeValueState={this.updateMazeValueState.bind(this)}\r\n                updatePathState={this.updatePathState.bind(this)}\r\n                updateMazeState={this.updateMazeState.bind(this)}\r\n                visualizeDijkstra={this.visualizeDijkstra.bind(this)}\r\n                visualizeBidirectionalBFSSearch={this.visualizeBidirectionalBFSSearch.bind(\r\n                  this\r\n                )}\r\n                visualizeDFS={this.visualizeDFS.bind(this)}\r\n                visualizeBFS={this.visualizeBFS.bind(this)}\r\n                visualizeAstar={this.visualizeAstar.bind(this)}\r\n                visualizeGreedyBFS={this.visualizeGreedyBFS.bind(this)}\r\n                clearPath={this.clearPath.bind(this)}\r\n                updateSidebarSpeed={this.updateSidebarSpeed.bind(this)}\r\n                clearGridPartially={this.clearGridPartially.bind(this)}\r\n              />\r\n            </Route>\r\n          </Switch>\r\n        </Router>\r\n      </React.Fragment>\r\n    );\r\n  }\r\n}\r\nfunction getInitialNum(width, height) {\r\n  let numColumns;\r\n  if (width > 1500) {\r\n    numColumns = Math.floor(width / 25);\r\n  } else if (width > 1250) {\r\n    numColumns = Math.floor(width / 22.5);\r\n  } else if (width > 1000) {\r\n    numColumns = Math.floor(width / 20);\r\n  } else if (width > 750) {\r\n    numColumns = Math.floor(width / 17.5);\r\n  } else if (width > 500) {\r\n    numColumns = Math.floor(width / 15);\r\n  } else if (width > 250) {\r\n    numColumns = Math.floor(width / 12.5);\r\n  } else if (width > 0) {\r\n    numColumns = Math.floor(width / 10);\r\n  }\r\n  let cellWidth = Math.floor(width / numColumns);\r\n  let numRows = Math.floor(height / cellWidth);\r\n  return [numRows, numColumns];\r\n}\r\n\r\n// Function to create grid using each node with rows and column\r\nconst getInitialGrid = (numRows, numCols) => {\r\n  let grid = [];\r\n  for (let row = 0; row < numRows - 9; row++) {\r\n    let currentRow = [];\r\n    for (let col = 0; col < numCols; col++) {\r\n      currentRow.push(createNode(row, col));\r\n    }\r\n    grid.push(currentRow);\r\n  }\r\n  return grid;\r\n};\r\n\r\n// Function to create each cell of the grid\r\nconst createNode = (row, col) => {\r\n  return {\r\n    row,\r\n    col,\r\n    isStart: row === startNodeRow && col === startNodeCol,\r\n    isFinish: row === finishNodeRow && col === finishNodeCol,\r\n    distance: Infinity,\r\n    totalDistance: Infinity,\r\n    isVisited: false,\r\n    isShortest: false,\r\n    isWall: false,\r\n    previousNode: null,\r\n  };\r\n};\r\n\r\nconst getNewGridWithWalls = (grid, row, col) => {\r\n  let newGrid = grid.slice();\r\n  let node = grid[row][col];\r\n  let newNode = {\r\n    ...node,\r\n    isWall: !node.isWall,\r\n  };\r\n  newGrid[row][col] = newNode;\r\n  return newGrid;\r\n};\r\n\r\nconst newGridWithMaze = (grid, walls) => {\r\n  let newGrid = grid.slice();\r\n  for (let wall of walls) {\r\n    let node = grid[wall[0]][wall[1]];\r\n    let newNode = {\r\n      ...node,\r\n      isWall: true,\r\n    };\r\n    newGrid[wall[0]][wall[1]] = newNode;\r\n  }\r\n  return newGrid;\r\n};\r\n\r\nconst getGridWithoutPath = (grid) => {\r\n  let newGrid = grid.slice();\r\n  for (let row of grid) {\r\n    for (let node of row) {\r\n      let newNode = {\r\n        ...node,\r\n        distance: Infinity,\r\n        totalDistance: Infinity,\r\n        isVisited: false,\r\n        isShortest: false,\r\n        previousNode: null,\r\n      };\r\n      newGrid[node.row][node.col] = newNode;\r\n    }\r\n  }\r\n  return newGrid;\r\n};\r\n\r\nfunction getRandomNums(num) {\r\n  let randomNums1 = [];\r\n  let temp = 2;\r\n  for (let i = 5; i < num / 2; i += 2) {\r\n    randomNums1.push(temp);\r\n    temp += 2;\r\n  }\r\n  let randomNums2 = [];\r\n  temp = -2;\r\n  for (let i = num / 2; i < num - 5; i += 2) {\r\n    randomNums2.push(temp);\r\n    temp -= 2;\r\n  }\r\n  return [randomNums1, randomNums2];\r\n}\r\n\r\nfunction getStartFinishNode(numRows, numColumns) {\r\n  let randomNums;\r\n  let x;\r\n  let y;\r\n  let startNodeRow;\r\n  let startNodeCol;\r\n  let finishNodeRow;\r\n  let finishNodeCol;\r\n  if (numRows < numColumns) {\r\n    randomNums = getRandomNums(numRows);\r\n    x = Math.floor(numRows / 2);\r\n    y = Math.floor(numColumns / 4);\r\n    if (x % 2 !== 0) x -= 1;\r\n    if (y % 2 !== 0) y += 1;\r\n    startNodeRow =\r\n      x + randomNums[1][Math.floor(Math.random() * randomNums[1].length)];\r\n    startNodeCol = y + [-6, -4, -2, 0][Math.floor(Math.random() * 4)];\r\n    finishNodeRow =\r\n      x + randomNums[0][Math.floor(Math.random() * randomNums[0].length)];\r\n    finishNodeCol =\r\n      numColumns - y + [0, 2, 4, 6][Math.floor(Math.random() * 4)];\r\n    console.log(x, y);\r\n  } else {\r\n    randomNums = getRandomNums(numColumns);\r\n    x = Math.floor(numRows / 4);\r\n    y = Math.floor(numColumns / 2);\r\n    if (x % 2 !== 0) x -= 1;\r\n    if (y % 2 !== 0) y += 1;\r\n    startNodeRow = x + [-6, -4, -2, 0][Math.floor(Math.random() * 4)];\r\n    startNodeCol =\r\n      y + randomNums[1][Math.floor(Math.random() * randomNums[1].length)];\r\n    finishNodeRow = numRows - x + [0, 2, 4, 6][Math.floor(Math.random() * 4)];\r\n    finishNodeCol =\r\n      y + randomNums[0][Math.floor(Math.random() * randomNums[0].length)];\r\n  }\r\n  return [startNodeRow, startNodeCol, finishNodeRow, finishNodeCol];\r\n}\r\n\r\nconst updateNodesForRender = (\r\n  grid,\r\n  nodesInShortestPathOrder,\r\n  visitedNodesInOrder\r\n) => {\r\n  let newGrid = grid.slice();\r\n  for (let node of visitedNodesInOrder) {\r\n    if (\r\n      (node.row === startNodeRow && node.col === startNodeCol) ||\r\n      (node.row === finishNodeRow && node.col === finishNodeCol)\r\n    )\r\n      continue;\r\n    let newNode = {\r\n      ...node,\r\n      isVisited: true,\r\n    };\r\n    newGrid[node.row][node.col] = newNode;\r\n  }\r\n  for (let node of nodesInShortestPathOrder) {\r\n    if (node.row === finishNodeRow && node.col === finishNodeCol) {\r\n      return newGrid;\r\n    }\r\n    let newNode = {\r\n      ...node,\r\n      isVisited: false,\r\n      isShortest: true,\r\n    };\r\n    newGrid[node.row][node.col] = newNode;\r\n  }\r\n};\r\nconst updateNodesForRenderBS = (\r\n  grid,\r\n  nodesInShortestPathOrder,\r\n  visitedNodesInOrder\r\n) => {\r\n  let newGrid = grid.slice();\r\n  for (let i = 0; i < visitedNodesInOrder; i++) {\r\n    for (let j = 0; j < visitedNodesInOrder[i].length; j++) {\r\n      const node = visitedNodesInOrder[i][j];\r\n      if (\r\n        (node.row === startNodeRow && node.col === startNodeCol) ||\r\n        (node.row === finishNodeRow && node.col === finishNodeCol)\r\n      )\r\n        continue;\r\n      let newNode = {\r\n        ...node,\r\n        isVisited: true,\r\n      };\r\n      newGrid[node.row][node.col] = newNode;\r\n    }\r\n  }\r\n  for (let node of nodesInShortestPathOrder) {\r\n    if (node.row === finishNodeRow && node.col === finishNodeCol) {\r\n      return newGrid;\r\n    }\r\n    let newNode = {\r\n      ...node,\r\n      isVisited: false,\r\n      isShortest: true,\r\n    };\r\n    newGrid[node.row][node.col] = newNode;\r\n  }\r\n};\r\n\r\nexport default Visualizer;\r\n","export function RandomWalls(grid, startNode, finishNode, rows, cols) {\r\n  if (!startNode || !finishNode || startNode === finishNode) {\r\n    return;\r\n  }\r\n  let walls = [];\r\n  const wallsToPutOnNodes = Math.floor((rows * cols) / 5);\r\n\r\n  for (let i = 0; i < wallsToPutOnNodes; ++i) {\r\n    let x = Math.floor(Math.random() * rows);\r\n    let y = Math.floor(Math.random() * cols);\r\n\r\n    if (\r\n      grid[x][y] !== startNode &&\r\n      grid[x][y] !== finishNode &&\r\n      !grid[x][y].isWall\r\n    ) {\r\n      walls.push([x, y]);\r\n    }\r\n  }\r\n  return walls;\r\n}\r\n","import React, { Component } from \"react\";\nimport \"./App.css\";\nimport Visualizer from \"./Components/PathfindingVisualizer/Visualizer\";\nimport { BrowserRouter as Router, Route, Switch, Link } from \"react-router-dom\";\nimport Tutorial from \"./Components/PathfindingVisualizer/Tutorial\";\n\nclass App extends Component {\n  render() {\n    return (\n      <>\n        <Visualizer></Visualizer>\n      </>\n    );\n  }\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}